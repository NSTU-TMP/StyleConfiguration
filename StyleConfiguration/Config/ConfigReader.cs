using System;using System.Collections.Generic;using System.Collections.ObjectModel;using System.IO;using System.Linq;using Avalonia.Controls;using DynamicData;using DynamicData.Tests;namespace StyleConfiguration.Config;public class ConfigReader{    private string _pathToConfig;    private readonly StreamReader _sr;    private string[] config;    public ObservableCollection<MenuItem> Items { get; }    public ConfigReader(string pathToConfig)    {        _pathToConfig = pathToConfig;        _sr = new StreamReader(_pathToConfig);        Items = new ObservableCollection<MenuItem>();    }    public bool Parsing()    {        var line = _sr.ReadLine();        if (line == null) return false;                var splitLine = line.Split();        while (line != null)        {            if (splitLine.Length is 4 or 3 && splitLine[0] != "1")            {                var tmp = new MenuItem                {                    Header = splitLine[1]                };                if (splitLine[2] == "1") tmp.IsEnabled = false;                if (splitLine[2] == "2") tmp.IsVisible = false;                                Items.Add(tmp);            }            else if (splitLine.Length is 4 or 3 && splitLine[0] == "1")            {                var newItems = new List<MenuItem>();                                Items[^1].Items = new List<MenuItem>[]{};                                while (splitLine[0] == "1")                {                    var tmp = new MenuItem()                    {                        Header = splitLine[1]                    };                                        if (splitLine[2] == "1") tmp.IsEnabled = false;                    if (splitLine[2] == "2") tmp.IsVisible = false;                                        newItems.Add(tmp);                    line = _sr.ReadLine();                                        if (line != null) splitLine = line.Split();                    else break;                    if (splitLine.Length is < 3 or > 4) return false;                }                Items[^1].Items = newItems;                continue;            }            else            {                Items.Clear();                return false;            }            line = _sr.ReadLine();            if (line != null) splitLine = line.Split();        }                return true;    }}