using System;using System.Collections.Generic;using System.Collections.ObjectModel;using System.Diagnostics;using System.IO;using Avalonia.Controls;using DynamicData;namespace StyleConfiguration.Config;public class ConfigReader{    private readonly StreamReader? _sr;    public ObservableCollection<MenuItem> MenuItems { get; private set; }    public ConfigReader(string? pathToConfig)    {        if (pathToConfig != null)        {            _sr = new StreamReader(pathToConfig);        }        MenuItems = new ObservableCollection<MenuItem>();    }    private bool IsLineCorrect(string[] splitLine) => splitLine.Length is 3 or 4;     public bool Parsing()    {        var line = _sr?.ReadLine();        if (line == null) return false;        var splitLine = line.Split();        /*       0       0       0       0       0           1           1               2                   3                   3                       4               2                   3           1               2               2                   3       0           1           1        */                int counter = 0;        var rootTitles = new List<MenuItem>();        var currentTitles = rootTitles;        var previousMenuItem = new MenuItem();        // ref MenuItem prevMenuItem = rootTitles[^1];        // var x = ref rootTitles[0];        while (line is not null)        {            if (splitLine != null && IsLineCorrect(splitLine))            {                var titleStep = Int32.Parse(splitLine[0]);                if (titleStep == counter) // остаемся тут же                 {                    currentTitles.Add(new MenuItem                    {                        Header = splitLine[1],                        IsEnabled = splitLine[2] != "1",                        IsVisible = splitLine[2] != "2",                    });                    var currentTitle = currentTitles[0];                    previousMenuItem =  currentTitles[^1];                }                else if (titleStep > counter) // добавляем текущему ребенка                {                    counter++;                    currentTitles = new List<MenuItem>();                    currentTitles.Add(new MenuItem                    {                        Header = splitLine[1],                        IsEnabled = splitLine[2] != "1",                        IsVisible = splitLine[2] != "2",                    });                    previousMenuItem.Items = currentTitles;                    // previousMenuItem = currentTitles[^1];                }                else if (titleStep < counter) // спустились на шаг(мб несколько) вниз                {                    // counter++;                    return false;                }             }            line = _sr?.ReadLine();            splitLine = line?.Split();        }        MenuItems = new ObservableCollection<MenuItem>(rootTitles);        return true;        // while (line != null)        // {        //     if (IsLineCorrect(line))        //     {        //         int subTitleNumber = Int32.Parse(splitLine[0]);        //         if (subTitleNumber  == counter)        //         {        //             var item = new MenuItem        //             {        //                 Header = splitLine[1],        //                 IsEnabled = splitLine[2] != "1",        //                 IsVisible = splitLine[2] != "2",        //                 Items = null        //             };        //        //             if (counter == 0)        //             {        //                 MenuItems.Add(item);        //             }        //             else        //             {        //                 var x = MenuItems[^1];        //                 var y = x.Items;        //                 for (int i = 0; i < counter; i++)        //                 {        //                     if (x.Items is not null)        //                     {        //                         y = x.Items;        //                     }        //                     else        //                     {        //                         break;        //                     }        //                 }        //                 var newItems = new List<MenuItem>();        //                 subTitles.Add(item);        //                         //             }        //                     //         }        //         else if (subTitleNumber != 0)        //         {        //             var newItems = new List<MenuItem>();        //        //             if (splitLine[0] == "1")        //             {        //                 MenuItems[^1].Items = new List<MenuItem>[] { };        //             }        //        //             string buf = splitLine[0];        //                     //             while (splitLine[0] == buf)        //             {        //                 var tmp = new MenuItem()        //                 {        //                     Header = splitLine[1]        //                 };        //        //                 if (splitLine[2] == "1") tmp.IsEnabled = false;        //                 if (splitLine[2] == "2") tmp.IsVisible = false;        //        //                 newItems.Add(tmp);        //                 line = _sr?.ReadLine();        //        //                 if (line != null) splitLine = line.Split();        //                 else break;        //        //                 if (splitLine.Length is < 3 or > 4) return false;        //             }        //        //             MenuItems[^1].Items = newItems;        //        //             continue;        //         }        //         else        //         {        //             MenuItems.Clear();        //             return false;        //         }        //     }        //        //     line = _sr?.ReadLine();        //     if (line != null)        //     {        //         splitLine = line.Split();        //         counter++;        //     }        // }        //        // return true;    }}