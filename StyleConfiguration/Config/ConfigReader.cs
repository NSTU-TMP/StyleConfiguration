using System;using System.Collections.Generic;using System.Collections.ObjectModel;using System.Diagnostics;using System.IO;using Avalonia.Controls;using DynamicData;namespace StyleConfiguration.Config;public class ConfigReader{    private readonly StreamReader? _sr;    public ObservableCollection<MenuItem> MenuItems { get; private set; }    public ConfigReader(string? pathToConfig)    {        if (pathToConfig != null)        {            _sr = new StreamReader(pathToConfig);        }        MenuItems = new ObservableCollection<MenuItem>();    }    private bool IsLineCorrect(string[] splitLine) => splitLine.Length is 3 or 4;     public bool Parsing()    {        var line = _sr?.ReadLine();        if (line == null) return false;        var splitLine = line.Split();        /*       0       0       0       0       0           1                2           1                2                   3                   3                       4                       4                       4                            5                            5                            5                                    2                   3           1               2               2                   3       0           1           1        */                int counter = 0;        var rootTitles = new List<MenuItem>();        var currentTitles = rootTitles;        var previousMenuItem = new MenuItem();        // ref MenuItem prevMenuItem = rootTitles[^1];        // var x = ref rootTitles[0];        while (line is not null)        {            if (splitLine != null && IsLineCorrect(splitLine))            {                var titleStep = Int32.Parse(splitLine[0]);                if (titleStep == counter) // остаемся тут же                 {                    currentTitles.Add(new MenuItem                    {                        Header = splitLine[1],                        IsEnabled = splitLine[2] != "1",                        IsVisible = splitLine[2] != "2",                    });                    previousMenuItem =  currentTitles[^1];                }                else if (titleStep == counter + 1) // добавляем текущему ребенка                {                    counter++;                    currentTitles = new List<MenuItem>();                    currentTitles.Add(new MenuItem                    {                        Header = splitLine[1],                        IsEnabled = splitLine[2] != "1",                        IsVisible = splitLine[2] != "2",                    });                    previousMenuItem.Items = currentTitles;                    previousMenuItem = currentTitles[^1];                }                else if (titleStep < counter && titleStep > 0) // спустились на шаг(мб несколько) вниз                {                    counter = titleStep;                                        currentTitles = rootTitles;                    for (int i = 0; i < titleStep; i++)                    {                        if (currentTitles is null) return false;                        previousMenuItem = currentTitles[^1];                        currentTitles = currentTitles[^1].Items as List<MenuItem>;                    }                    if (currentTitles is null) return false;                                        currentTitles.Add(new MenuItem                    {                        Header = splitLine[1],                        IsEnabled = splitLine[2] != "1",                        IsVisible = splitLine[2] != "2",                    });                }                else                {                    return false;                }            }            line = _sr?.ReadLine();            splitLine = line?.Split();        }        MenuItems = new ObservableCollection<MenuItem>(rootTitles);        return true;    }}